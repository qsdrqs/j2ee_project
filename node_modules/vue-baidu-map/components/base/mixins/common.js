'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var types = {
  control: {
    unload: 'removeControl'
  },
  layer: {
    unload: 'removeTileLayer'
  },
  overlay: {
    unload: 'removeOverlay'
  },
  contextMenu: {
    unload: 'removeContextMenu'
  }
};

var getParent = function getParent($component) {
  return $component.abstract || $component.$el === $component.$children[0].$el ? getParent($component.$parent) : $component;
};

var Mixin = function Mixin(prop) {
  _classCallCheck(this, Mixin);

  this.methods = {
    ready: function ready() {
      var $parent = getParent(this.$parent);
      var BMap = this.BMap = $parent.BMap;
      var map = this.map = $parent.map;
      this.load();
      this.$emit('ready', {
        BMap: BMap,
        map: map
      });
    },
    transmitEvent: function transmitEvent(e) {
      this.$emit(e.type.replace(/^on/, ''), e);
    },
    reload: function reload() {
      var _this = this;

      this && this.BMap && this.$nextTick(function () {
        _this.unload();
        _this.$nextTick(_this.load);
      });
    },
    unload: function unload() {
      var map = this.map,
          originInstance = this.originInstance;

      try {
        switch (prop.type) {
          case 'search':
            return originInstance.clearResults();
          case 'autoComplete':
          case 'lushu':
            return originInstance.dispose();
          case 'markerClusterer':
            return originInstance.clearMarkers();
          default:
            map[types[prop.type].unload](originInstance);
        }
      } catch (e) {}
    }
  };
  this.computed = {
    renderByParent: function renderByParent() {
      return this.$parent.preventChildrenRender;
    }
  };
  this.mounted = function () {
    var $parent = getParent(this.$parent);
    var map = $parent.map;
    var ready = this.ready;

    map ? ready() : $parent.$on('ready', ready);
  };
  this.beforeDestroy = function () {
    var unload = this.unload,
        renderByParent = this.renderByParent,
        $parent = this.$parent;

    if (renderByParent) {
      $parent.reload();
    }
    unload();
  };
};

exports.default = function (type) {
  return new Mixin({ type: type });
};